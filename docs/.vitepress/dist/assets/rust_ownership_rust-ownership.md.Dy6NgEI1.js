import{_ as s,c as a,o as n,a2 as i}from"./chunks/framework.BBCWOUBu.js";const E=JSON.parse('{"title":"Rsut 所有权机制","description":"","frontmatter":{},"headers":[],"relativePath":"rust/ownership/rust-ownership.md","filePath":"rust/ownership/rust-ownership.md"}'),p={name:"rust/ownership/rust-ownership.md"},e=i(`<h1 id="rsut-所有权机制" tabindex="-1">Rsut 所有权机制 <a class="header-anchor" href="#rsut-所有权机制" aria-label="Permalink to &quot;Rsut 所有权机制&quot;">​</a></h1><p>所有权是Rsut中最独特的特性，它让Rust无需GC就可以保证内存安全。</p><h2 id="什么是所有权" tabindex="-1">什么是所有权？ <a class="header-anchor" href="#什么是所有权" aria-label="Permalink to &quot;什么是所有权？&quot;">​</a></h2><p><strong>所有权</strong>（<em>ownership</em>）是 Rust 用于如何管理内存的一组规则。所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。<strong>Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。</strong></p><p>摘自：<a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83" target="_blank" rel="noreferrer">什么是所有权</a></p><h3 id="栈内存和堆内存-stack-vs-heap" tabindex="-1">栈内存和堆内存（Stack vs Heap） <a class="header-anchor" href="#栈内存和堆内存-stack-vs-heap" aria-label="Permalink to &quot;栈内存和堆内存（Stack vs Heap）&quot;">​</a></h3><p>在Rust语言中，一个值在栈内存还是堆内存，对语言的行为和编码时要为此做的操作有更大的影响。</p><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。</p><p>增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。</p><h3 id="所有权规则" tabindex="-1">所有权规则 <a class="header-anchor" href="#所有权规则" aria-label="Permalink to &quot;所有权规则&quot;">​</a></h3><ol><li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol><h3 id="变量的作用域" tabindex="-1">变量的作用域 <a class="header-anchor" href="#变量的作用域" aria-label="Permalink to &quot;变量的作用域&quot;">​</a></h3><p>字符串字面值是被硬编码进程序里的字符串值，不可变，存储在栈当中，并且当离开作用域时被移出栈。String类型存储在堆当中，可变，所以在这里更适合用来讨论所有权机制以及变量作用域的情况。</p><p><strong>Rust释放无用内存的策略：内存在拥有它的变量离开作用域后就被自动释放。</strong></p><p>使用大括号可以自定义变量的作用域范围，以下分别是字符串字面值和String类型的关于作用域的示例：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串字面值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s 在这里无效，它尚未声明</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从此处起，s 是有效的</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用 s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此作用域已结束，s 不再有效</span></span></code></pre></div><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// String 类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从此处起，s 是有效的</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用 s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}                                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此作用域已结束，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                   // s 不再有效</span></span></code></pre></div><h3 id="string类型" tabindex="-1">String类型 <a class="header-anchor" href="#string类型" aria-label="Permalink to &quot;String类型&quot;">​</a></h3><p>演示String类型的变量作用域，y和x 指向堆中的同一块内存区域，Rust为了保证内存安全，如果x赋值给了y，就会结束x的作用域，代码示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    let x = String::from(&quot;5&quot;);</span></span>
<span class="line"><span>    let y = x;</span></span>
<span class="line"><span>    println!(&quot;x:{}&quot;, x);</span></span></code></pre></div><p>执行结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>   |</span></span>
<span class="line"><span>11 |     let x = String::from(&quot;5&quot;);</span></span>
<span class="line"><span>   |         - move occurs because \`x\` has type \`String\`, which does not implement the \`Copy\` trait</span></span>
<span class="line"><span>12 |     let y = x;</span></span>
<span class="line"><span>   |             - value moved here</span></span>
<span class="line"><span>13 |     println!(&quot;x:{}&quot;, x);</span></span>
<span class="line"><span>   |                      ^ value borrowed here after move</span></span></code></pre></div><p>两个数据指针指向了同一位置。这就有了一个问题：当 <code>x</code> 和 <code>y</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>为了确保内存安全，在 <code>let y = x;</code> 之后，Rust 认为 <code>x</code> 不再有效，因此 Rust 不需要在 <code>x</code> 离开作用域后清理任何东西。此时，只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存。</p><h3 id="clone" tabindex="-1">clone <a class="header-anchor" href="#clone" aria-label="Permalink to &quot;clone&quot;">​</a></h3><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    let x = String::from(&quot;5&quot;);</span></span>
<span class="line"><span>    let y = x.clone();</span></span>
<span class="line"><span>    println!(&quot;x:{}&quot;, x);</span></span></code></pre></div><p>存放在栈上的整形变量，经过移动后，依然有效。因为默认实现了 <code>Copy</code> trait，代码示例：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x:{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x</span></span></code></pre></div><p>执行结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>x:5</span></span></code></pre></div><p>如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。</p><p>如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h3 id="所有权与函数" tabindex="-1">所有权与函数 <a class="header-anchor" href="#所有权与函数" aria-label="Permalink to &quot;所有权与函数&quot;">​</a></h3><p>和变量之间进行赋值类似，变量在函数中的移动也会发生作用域的变化，代码示例：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takes_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(some_string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, some_string);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[cfg(test)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mod</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tests</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    use</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    #[test]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_takes_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        takes_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;s:{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, s); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里发生报错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>执行 <code>test_takes_ownership()</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error[E0382]: borrow of moved value: \`s\`</span></span>
<span class="line"><span>  --&gt; crates/ownership_demo/src/lib.rs:14:26</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>12 |         let s = String::from(&quot;hello&quot;);</span></span>
<span class="line"><span>   |             - move occurs because \`s\` has type \`String\`, which does not implement the \`Copy\` trait</span></span>
<span class="line"><span>13 |         takes_ownership(s);</span></span>
<span class="line"><span>   |                         - value moved here</span></span>
<span class="line"><span>14 |         println!(&quot;s:{}&quot;, s);</span></span>
<span class="line"><span>   |                          ^ value borrowed here after move</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>note: consider changing this parameter type in function \`takes_ownership\` to borrow instead if owning the value isn&#39;t necessary</span></span>
<span class="line"><span>  --&gt; crates/ownership_demo/src/lib.rs:1:33</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>1  | fn takes_ownership(some_string: String) {</span></span>
<span class="line"><span>   |    ---------------              ^^^^^^ this parameter takes ownership of the value</span></span>
<span class="line"><span>   |    |</span></span>
<span class="line"><span>   |    in this function</span></span>
<span class="line"><span>   = note: this error originates in the macro \`$crate::format_args_nl\` which comes from the expansion of the macro \`println\` (in Nightly builds, run with -Z macro-backtrace for more info)</span></span>
<span class="line"><span>help: consider cloning the value if the performance cost is acceptable</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>13 |         takes_ownership(s.clone());</span></span>
<span class="line"><span>   |</span></span></code></pre></div><p>当 <code>s</code> 传入到函数当中时，s的作用域就到了函数中，函数后面再获取s将不被允许，发生编译错误，执行也会发生异常。</p><p>但是对于类型是i32类型的参数，情况不同，代码示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fn takes_ownership(some_string: String) {</span></span>
<span class="line"><span>    println!(&quot;{}&quot;, some_string);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn takes_ownership_i32(value: i32) {</span></span>
<span class="line"><span>    println!(&quot;{}&quot;, value);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[cfg(test)]</span></span>
<span class="line"><span>mod tests {</span></span>
<span class="line"><span>    use super::*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    #[test]</span></span>
<span class="line"><span>    fn test_takes_ownership() {</span></span>
<span class="line"><span>        let s = String::from(&quot;hello&quot;);</span></span>
<span class="line"><span>        takes_ownership(s);</span></span>
<span class="line"><span>        //println!(&quot;s:{}&quot;, s);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    #[test]</span></span>
<span class="line"><span>    fn test_takes_ownership_i32() {</span></span>
<span class="line"><span>        let value = 12;</span></span>
<span class="line"><span>        takes_ownership_i32(value);</span></span>
<span class="line"><span>        println!(&quot;value:{}&quot;, value);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>执行 <code>test_takes_ownership_i32()</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>running 1 test</span></span>
<span class="line"><span>test tests::test_takes_ownership_i32 ... ok</span></span>
<span class="line"><span></span></span>
<span class="line"><span>successes:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>---- tests::test_takes_ownership_i32 stdout ----</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>value:12</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>successes:</span></span>
<span class="line"><span>    tests::test_takes_ownership_i32</span></span></code></pre></div><p>同理，如果一个类型实现了 <code>Copy</code> trait，那么一个变量在将其传递到函数当中后，函数之后可以再读取该变量。</p><h3 id="返回值与作用域" tabindex="-1">返回值与作用域 <a class="header-anchor" href="#返回值与作用域" aria-label="Permalink to &quot;返回值与作用域&quot;">​</a></h3><p>返回值也可以转移所有权。</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回一个String 类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gives_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s进入作用域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s                              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s 返回给调用函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[test]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_gives_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gives_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s进入作用域</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    takes_ownership</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s作用域移到takes_ownership函数中</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;s:{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, s); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// s 已经被移走，这里会报错  borrow of moved value: \`s\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>由此可见，变量在函数调用过程中，作用域会随着函数传入变量，函数返回变量发生变化，无法顺畅的在函数调用后继续使用变量。</p><p>这里就引入了<strong>引用</strong>的概念，可以使用<strong>引用</strong>实现丝滑的使用变量和函数。</p>`,50),t=[e];function l(h,k,r,o,c,d){return n(),a("div",null,t)}const u=s(p,[["render",l]]);export{E as __pageData,u as default};
